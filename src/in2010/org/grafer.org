#+title: Grafer
#+author: Aksel Olav Steen
#+date: Nov 22 2025
:PROPERTIES:
#+options: toc:nil num:nil
#+latex_header: \setlength{\parindent}{0pt}
#+latex_header: \usepackage[margin=3cm]{geometry}
#+latex_engraved_theme: nano-light
:END:

* Litt om grafer
  Grafer finnes i alle mulige former. Vi ser de oftest i kart, men også i
  nettverk, og faktiske biologiske trær. Grafer lar oss kort sagt vise hvordan
  ting henger sammen. \\

  En graf er lettest definert som en mengde av to mengder, V og E. V inneholder
  alle nodene i grafen, som også kan bli kalt vertex på engelsk. E inneholder
  alle kantene, som da er mengder med 2 noder som forteller oss at nodene er
  relatert. \\
  
  I in2010 har vi ikke parallelle kanter eller løkker, så les in1150 om du
  trenger info om de. \\

** Retning
   Det at en graf har en retning betyr at man har en kant til, men ikke
   nødvendigvis tilbake. Med andre ord så har rettede grafer kanter som tupler,
   og ikke mengder. \\

** Vekt
   En vektet graf har en vekt over enhver kant, og har ofte en assosiert vekt
   funksjon kalt w. For enhver kant fra u til v, vil w(u,v) angi vekten på
   kanten. \\

   I vektede grafer er vi oftest interessert i den /korteste/ stien, altså den
   stien som har lavest akkumulert vekt. \\

** Spenntre
   Et spenntre er et tre som består av de samme nodene, og noen av kantene.
   Altså et spenntre er en Hamiltonsti. \\

   Når vi har en urettet, men vektet graf er det ofte nyttig å finne minimale
   spenntrær. Det er da Hamiltonstiene med lavest akkumulert vekt. Dette kan
   la oss for eksempel kartlegge den billigste ruten å legge nettverkskabler
   mellom bygg. \\

   En graf kan ha flere minimale spenntrær, et tilfellene er hvor alle kantene
   har samme vekt.

** Sammenheng
   En graf kalles sammenhengende hvis det finnes en sti mellom alle par av
   noder. Vi kan sjekke om en graf er sammenhengende med et enkelt (B|D)FS søk,
   om vi da har besøkt alle noder i grafen fra en vilkårlig node så er grafen
   sammenhengende. \\

   Om en graf ikke er sammenhengende kan den deles inn i komponenter. \\

   En graf er k-sammenhengende hvis grafen forblir sammenhengende selv hvis k-1
   vilkårlige noder fjernes. Sagt annerledes, det finnes k distinkte stier
   mellom hvert par av noder. \\

   Dette er nyttig for å kartlegge redundans eller sårbarheter. I et nettverk
   vil det bety at k-1 mange rutere kan gå ned, og vi fortsatt får sendt
   informasjon. I krigføring kan det brukes for å finne svake transportlinjer. \\
  

* Adjacency matrix
  O(|V^2|) \\
  Grafer \\

  Nabomatriser egner seg best for tette grafer. Med andre ord betyr det at jo
  fullere nabomatrisen er, jo bedre egner den seg. \\

  Nabomatriser egner seg ikke godt til å finne alle naboer til en node, siden
  vi da må iterere gjennom hele kolonnen eller raden. Men nabomatriser har
  konstant tid for å se om to noder er naboer. 


* Adjacency list
  O(|V| + |E|) \\
  Grafer \\

  Nabolister (Nabomap/Nabobuckets) egner seg best for tynne grafer, altså
  grafer med få kanter. Nabolister kan lett bli implementert ved hjelp av
  hashmaps, hvor nodene er nøklene, og verdiene er en liste med nabonoder. \\

  Nabolister egner seg godt for å finne alle naboer til en node, siden vi da
  kun bruker O(deg(v)), altså utgraden til v, i stedet for å løpe igjennom alle
  mulige noder. 


* DFS
  O(|V| + |E|) \\
  Grafer \\
  Klatrer i fjellveg \\

  DFS følger en vilkårlig sti vekk fra den gitte startnoden, og vil alltid
  prøve å finne ubesøkte noder som leder vekk fra starten. I de tilfellene som
  den ikke finner noen ubesøkte noder, så backtracker den til den finner nye
  ubesøkte noder som leder vekk. \\

  DFS blir ofte implementert rekursivt, hvor vi da implisit bruker en stack
  kalt /call stacken/, også kalt /runtime stacken/. DFS kan da også bli
  implementert med en eksplisitt stack, som da gjør den iterativ. \\

  DFS er den mest minne-effektive løsningen for å finne en sti mellom to noder.


* BFS
  O(|V| + |E|) \\
  Grafer \\
  
  BFS besøker hele tiden den nærmeste ubesøkte noden fra startnoden. Den jobber
  seg lagvis gjennom grafen, med å første besøke alle direkte naboer, også
  naboene sine naboer, osv,. Man kan se på BFS traversering som en løk. Man
  begynner i sentrum, og jobber seg lagvis utover, hvor da søkeområdet blir
  større og større. \\

  BFS blir brukt for å finne de korteste stiene fra en start node til andre
  noder, og blir implementert iterative ved bruk av en kø.
  

* Kahn's (TopSort)
  O(|V| + |E|) \\
  Grafer \\

  TopSort er den simpleste algoritmen for topologisk sortering. Tanken er å
  finne en vilkårlig node med inngrad null, deretter fjern den, og oppdater
  alle noder sin inngrad. Dette gjør vi så lenge vi har noder med inngrad null.

  Dersom det ikke går å topologisk sortere nodene på denne måten, altså at vi
  ikke får berørt alle nodene, så kan vi konkludere med at grafen inneholder en
  sykel. \\

  For hver node med initiell ingrad 0 blir plassert på en stack, deretter så
  itererer vi over stacken:

  1. Pop v fra stacken, og legg den til i en liste output.
  2. For hver nabonode u til v, fjern v som nabonode.
  3. Hvis u har en inngrad 0, push u på stacken.
  4. Hvis listen output er mindre en mengden noder, få panikk

     
* DFSTopSort
  O(|V| + |E|) \\
  Grafer \\

  En graf kan sorteres ved hjelp av et DFS søk, hvor vi da modifiserer DFSVisit til
  å legge nodene på en stack i postorder operasjon. Altså etter alle dens
  naboer er prosessert. \\

  Intuisjonen bak bruk av postorder er at nodene med utgrad null legges først
  på stacken, som da betyr at de nodene mot toppen av stacken er noder med
  ingrad null, og da kommer under de første poppsene.


* Litt om korte stier
  asdasd
  
  
* Dijkstra
  O((|V| + |E|) * log(|V|)) \\
  Vektede grafer \\

  Dijkstras algoritme er en måte for å finne stien mellom to noder med lavest
  akkumulert vekt. \\

  Tanken bak Dijkstra er å modifisere BFS til å ta høyde for kantenes vekt. Vi
  anvender da en prioritetskø, som ordner noder etter avstand fra startnoden,
  og vi besøker alltid den /nærmeste/ ubesøkte noden fra startnoden med hensyn
  til akkumulert vekt. \\

  Initielt setter vi avstanden til startnoden som 0, og alle andre noder som
  uendelig. Deretter itererer vi over køen, besøker alle nabonoder, og
  oppdaterer vekten hvis den er lavere. \\

  I Dijkstra så besøker vi alle noder én gang, hvor for hver node kaller vi
  RemoveMin. Vi besøker også alle kanter én gang, og kaller på Insert. Dijkstra
  får da O(|E| * log(|V|) + |V| * log(|V|)). Dette kan da faktoriseres ut til
  O((|E| + |V|) * log(|V|)). \\

  Dijkstra kan gi feil svar for grafer med negative vekter, fordi Dijkstra går
  ut i fra at den første løsningen er den beste. Hvis grafen da inneholder
  negative sykler vil den korteste stien aldri bli funnet, fordi det lønner vil
  alltid lønne seg å ta en runde til i syklusen.

  
* Bellman-Ford
  O(|V| * |E|) \\
  Vektede grafer \\

  Bellman-Ford er en ikke-grådig algoritme, og opererer rundt prinsippet om at
  en sti kan ikke inneholde mer enn |V| - 1 kanter. En sti med |V| kanter må
  inneholde en sykel. Algoritmen estimerer avstanden for alle noder /mange
  ganger/, hvor da |V| - 1 ganger er nok. \\

  Hvis en node får en laverer estimert avstand etter |V| - 1 iterasjoner, så
  inneholder grafen en negativ sykel. \\

  BF går igjennom alle kanter |V| ganger, siden kanter er menger med to noder
  kan i verste tilfellet for tette grafer videre forenkles til O(|V|^3). 

  
* DAGShortestPath
  O(|V| + |E|) \\
  Vektede grafer \\

  For å finne den korteste stien i en DAG, så må vi først sortere grafen ved
  hjelp av Kahn's eller DFSTopSort. Deretter utøver vi standard korteste sti
  algoritme ved å iterere over alle sorterte noder, og sjekke den akkumulerte
  vekten til alle kantene. \\

  Topologisk sortering blir gjort i O(|V| + |E|) tid, og vi må deretter besøke
  alle noder i O(|V|) tid, og alle kanter i O(|E|) tid.
  
  
* Prim's
  O((|V| + |E|) * log(|V|)) \\
  Vektede grafer \\

  Prims algoritme bygger opp et minimalt spenntre grådig, ved å iterere over en
  prioritetskø, med kanter. I motsetning av Dijkstra så bryr vi oss ikke om den
  akkumulerte vekten, men kun om vekten som er minst i hvert tilfelle. \\

  Prims starter i en vilkårlig node, og sammenkobler enhver nabonode som ikke
  er i T med lavest vekt. \\

  For enhver ubesøkte node, så indekseres den med foreldren som verdi, og deretter så
  kastes alle kanter til noden på køen med kantvekten som prioritet.
  
  
* Kruskal
  O(|E| * log(|E|))
  Vektede grafer \\

  I motsettning til Prims, så vil Kruskal bygge opp ett spenntre for hver
  komponent. Dette betyr da at en sammenhengede graf fortsatt for ett spenntre,
  men en graf med komponenter vil da får en spennskog, hvor hver komponent vil
  ha et tilsvarende spenntre. \\

  Kruskal går igjennom en prioritetskø av alle kanter prioritert på vekt. Hvis
  det ikke eksisterer en sti mellom nodene, så blir kanten lagt til i spenntreet. 
  
  
* Boruvkas
  O(|E| * log(|V|)) \\
  Vektede grafer \\
  
  I likhet med Kruskal så lager Boruvkas en spennskog. I utgangspunktet
  opererer Boruvkas med at enhver node er en komponent. Så lenge det er mer en
  en komponenter, så gjøres følgende for hver komponent:
  
  1. Finn den laveste vektet kanten som kobler to komponenter sammen.
     + Dette skjer for alle komponenter, i parallell.
  2. Legg til denne kanten i MST, og sammenslå komponentene.

  Etter enhver iterasjon vil komponentene minst halveres, dette gir oss da
  O(log(|V|)) iterasjoner. For hver iterasjon så sjekkes |E| kanter, som da gir
  oss O(|E| * log(|V|))

  
* Tarjan
  O(|V| + |E|)
  Sammenhengende grafer \\

  
* Kosaraju
  O(|V| + |E|)
  Sammenhengende grafer \\
